import pandas as pd
import numpy as np
from scipy.stats import spearmanr

def transform_numerics_targetwise_monotonic(X_train, y_train, X_val, X_test,
                                            numerical_cols=None,
                                            min_group_size=50,
                                            ratio_jump_threshold=0.05,
                                            keep_original=True):
    def target_ratio_monotonic_grouping(feature_series, target_series, min_group_size=50, ratio_jump_threshold=0.05):
        stats = (
            pd.DataFrame({'value': feature_series, 'target': target_series})
            .groupby('value')
            .agg(count=('target', 'count'), target_ratio=('target', 'mean'))
            .sort_index()
            .reset_index()
        )

        group_ids = []
        current_group = 0
        group_start_idx = 0
        last_ratio = stats.loc[0, 'target_ratio']
        direction = None

        for i in range(1, len(stats)):
            current_ratio = stats.loc[i, 'target_ratio']
            total_count = stats.loc[group_start_idx:i, 'count'].sum()
            jump = current_ratio - last_ratio

            if direction is None:
                direction = np.sign(jump)

            if (
                np.sign(jump) == direction and
                abs(jump) >= ratio_jump_threshold and
                total_count >= min_group_size
            ):
                group_ids.extend([current_group] * (i - group_start_idx))
                current_group += 1
                group_start_idx = i
                last_ratio = current_ratio
            else:
                last_ratio = (stats.loc[group_start_idx:i, 'target_ratio'] * stats.loc[group_start_idx:i, 'count']).sum() / stats.loc[group_start_idx:i, 'count'].sum()

        group_ids.extend([current_group] * (len(stats) - len(group_ids)))
        stats['group'] = group_ids

        group_map = stats.set_index('value')['group'].to_dict()
        grouped_feature = feature_series.map(group_map).fillna(-1).astype(int)

        group_defs = []
        for group_id in sorted(stats['group'].unique()):
            group_values = stats[stats['group'] == group_id]['value'].tolist()
            target_avg = stats[stats['group'] == group_id]['target_ratio'].mean()
            group_defs.append({
                'group_id': group_id,
                'value_range': (min(group_values), max(group_values)),
                'values': group_values,
                'target_ratio_avg': round(target_avg, 4)
            })

        return grouped_feature, group_defs

    if numerical_cols is None:
        numerical_cols = X_train.select_dtypes(include=np.number).columns.tolist()

    X_train_new = X_train.copy()
    X_val_new = X_val.copy()
    X_test_new = X_test.copy()
    group_log = []

    for col in numerical_cols:
        try:
            grouped_train, group_defs = target_ratio_monotonic_grouping(
                X_train[col], y_train,
                min_group_size=min_group_size,
                ratio_jump_threshold=ratio_jump_threshold
            )
            new_col_name = f"{col}_transformed_grouped"
            X_train_new[new_col_name] = grouped_train
            X_val_new[new_col_name] = X_val[col].map(grouped_train.drop_duplicates()).fillna(-1).astype(int)
            X_test_new[new_col_name] = X_test[col].map(grouped_train.drop_duplicates()).fillna(-1).astype(int)

            for g in group_defs:
                group_log.append({
                    'feature': col,
                    'new_feature': new_col_name,
                    'group_id': g['group_id'],
                    'value_range_start': g['value_range'][0],
                    'value_range_end': g['value_range'][1],
                    'target_ratio_avg': g['target_ratio_avg'],
                    'value_list': g['values']
                })

            if keep_original:
                X_train_new[col] = X_train[col]
                X_val_new[col] = X_val[col]
                X_test_new[col] = X_test[col]

        except Exception as e:
            print(f"{col} için gruplayamadık: {e}")

    group_log_df = pd.DataFrame(group_log)
    return X_train_new, X_val_new, X_test_new, group_log_df