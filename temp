import pandas as pd
import numpy as np
from sklearn.model_selection import StratifiedKFold
from xgboost import XGBClassifier
from sklearn.metrics import roc_auc_score
from scipy.stats.mstats import winsorize
from sklearn.preprocessing import KBinsDiscretizer


def target_aware_transform(X_train, y_train, X_val, X_test, model_params=None, numerical_cols=None, keep_original=True, n_bins=5):
    """
    Target-aware dönüşüm: her numerik feature için en iyi target bazlı dönüşümü belirler ve uygular.
    Sadece X_train kullanılarak dönüşüm belirlenir, X_val ve X_test'e aynı dönüşüm uygulanır.

    Params:
        X_train, y_train: Train dataset
        X_val, X_test: Val ve test (sadece dönüşüm uygulanır)
        model_params: XGBoost parametreleri
        numerical_cols: Sadece bu kolonlar üzerinde dönüşüm yapılır
        keep_original: Orijinal feature da saklansın mı
        n_bins: Binning için kaç grup oluşturulsun

    Returns:
        X_train_new, X_val_new, X_test_new: dönüştürülmüş datasetler
        summary_df: her feature için dönüşüm özeti
    """
    if model_params is None:
        model_params = {
            'n_estimators': 50,
            'max_depth': 3,
            'learning_rate': 0.1,
            'use_label_encoder': False,
            'eval_metric': 'logloss',
            'random_state': 42
        }

    if numerical_cols is None:
        numerical_cols = X_train.select_dtypes(include=np.number).columns.tolist()

    X_train_new = X_train.copy()
    X_val_new = X_val.copy()
    X_test_new = X_test.copy()
    summary = []

    skf = StratifiedKFold(n_splits=3, shuffle=True, random_state=42)

    for col in numerical_cols:
        col_data = X_train[col]
        y_data = y_train

        candidates = {}

        # 1. Orijinal feature
        candidates['original'] = col_data.values

        # 2. Winsorized
        try:
            capped = winsorize(col_data, limits=[0.01, 0.01])
            candidates['winsorized'] = capped
        except Exception:
            pass

        # 3. Quantile binning + target ratio encoding
        try:
            kbin_q = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='quantile')
            binned_q = kbin_q.fit_transform(col_data.values.reshape(-1, 1)).astype(int).flatten()
            bin_ratios_q = pd.Series(binned_q).groupby(binned_q).apply(lambda b: y_data[b.index].mean())
            encoded_q = [bin_ratios_q[b] if b in bin_ratios_q else 0 for b in binned_q]
            candidates['quantile_target_encoded'] = encoded_q
        except Exception:
            pass

        # 4. Uniform binning + target ratio encoding
        try:
            kbin_u = KBinsDiscretizer(n_bins=n_bins, encode='ordinal', strategy='uniform')
            binned_u = kbin_u.fit_transform(col_data.values.reshape(-1, 1)).astype(int).flatten()
            bin_ratios_u = pd.Series(binned_u).groupby(binned_u).apply(lambda b: y_data[b.index].mean())
            encoded_u = [bin_ratios_u[b] if b in bin_ratios_u else 0 for b in binned_u]
            candidates['uniform_target_encoded'] = encoded_u
        except Exception:
            pass

        # Her dönüşüm için AUC değerlendirmesi
        best_auc = -1
        best_name = None
        for name, transformed_feature in candidates.items():
            try:
                X_temp = pd.DataFrame({col: transformed_feature})
                aucs = []
                for train_idx, val_idx in skf.split(X_temp, y_data):
                    X_t, X_v = X_temp.iloc[train_idx], X_temp.iloc[val_idx]
                    y_t, y_v = y_data.iloc[train_idx], y_data.iloc[val_idx]

                    model = XGBClassifier(**model_params)
                    model.fit(X_t, y_t)
                    preds = model.predict_proba(X_v)[:, 1]
                    auc = roc_auc_score(y_v, preds)
                    aucs.append(auc)

                mean_auc = np.mean(aucs)
                if mean_auc > best_auc:
                    best_auc = mean_auc
                    best_name = name
            except Exception:
                continue

        # En iyi dönüşümü uygula
        final_transform = candidates[best_name]
        new_col_name = f"{col}_transformed"

        X_train_new[new_col_name] = final_transform
        if keep_original:
            X_train_new[col] = X_train[col]

        # Aynı dönüşüm objesini val ve test'e uygula
        if best_name == 'original':
            X_val_new[new_col_name] = X_val[col]
            X_test_new[new_col_name] = X_test[col]

        elif best_name == 'winsorized':
            val_capped = winsorize(X_val[col], limits=[0.01, 0.01])
            test_capped = winsorize(X_test[col], limits=[0.01, 0.01])
            X_val_new[new_col_name] = val_capped
            X_test_new[new_col_name] = test_capped

        elif best_name == 'quantile_target_encoded':
            val_binned = kbin_q.transform(X_val[col].values.reshape(-1, 1)).astype(int).flatten()
            test_binned = kbin_q.transform(X_test[col].values.reshape(-1, 1)).astype(int).flatten()
            X_val_new[new_col_name] = [bin_ratios_q.get(b, 0) for b in val_binned]
            X_test_new[new_col_name] = [bin_ratios_q.get(b, 0) for b in test_binned]

        elif best_name == 'uniform_target_encoded':
            val_binned = kbin_u.transform(X_val[col].values.reshape(-1, 1)).astype(int).flatten()
            test_binned = kbin_u.transform(X_test[col].values.reshape(-1, 1)).astype(int).flatten()
            X_val_new[new_col_name] = [bin_ratios_u.get(b, 0) for b in val_binned]
            X_test_new[new_col_name] = [bin_ratios_u.get(b, 0) for b in test_binned]

        summary.append({
            'feature': col,
            'best_transformation': best_name,
            'cv_auc': best_auc
        })

    summary_df = pd.DataFrame(summary)
    return X_train_new, X_val_new, X_test_new, summary_df